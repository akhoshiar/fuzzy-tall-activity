<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Teacher – Height Category Boundaries</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f7f7f7; }
    h1 { margin-bottom: 0.2em; }
    .controls { margin-bottom: 1em; }
    button { padding: 6px 12px; cursor: pointer; margin-right: 6px; }
    canvas { background: #ffffff; border: 1px solid #ccc; margin-top: 15px; }
    #count { font-style: italic; margin-top: 4px; }
    #phaseNote { margin-top: 4px; font-size: 0.95em; }
  </style>
</head>
<body>
  <h1>Where Do Short / Medium / Tall Begin? – Class Results</h1>
  <p>
    Phase 1: students submit from their devices.<br>
    Phase 2: click <strong>“Show results”</strong> to reveal the boundaries for short and tall.
  </p>

  <div class="controls">
    <button id="showBtn">Show results</button>
    <button id="hideBtn">Hide results</button>
    <button id="downloadBtn">Download PNG</button>
    <button id="downloadDataBtn">Download CSV (for MATLAB)</button>
    <button id="clearBtn">Clear all votes (Firestore)</button>

    <div id="count">0 responses collected.</div>
    <div id="phaseNote"><strong>Phase 1:</strong> Collecting responses (graph is hidden).</div>
  </div>

  <canvas id="chart" width="900" height="260"></canvas>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import {
      getFirestore, collection, onSnapshot,
      deleteDoc, doc, getDocs
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyC4xLiPUb1TPZ_96jZHxOOZfeZvPonONIA",
      authDomain: "fuzzy-tall-demo.firebaseapp.com",
      projectId: "fuzzy-tall-demo",
      storageBucket: "fuzzy-tall-demo.firebasestorage.app",
      messagingSenderId: "892353419886",
      appId: "1:892353419886:web:0d61bf95a0de69d1f1647f",
      measurementId: "G-X44WSXCEWZ"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const votesRef = collection(db, "tall_votes");

    const canvas = document.getElementById("chart");
    const ctx = canvas.getContext("2d");
    const showBtn = document.getElementById("showBtn");
    const hideBtn = document.getElementById("hideBtn");
    const downloadBtn = document.getElementById("downloadBtn");
    const downloadDataBtn = document.getElementById("downloadDataBtn");
    const clearBtn = document.getElementById("clearBtn");
    const countEl = document.getElementById("count");
    const phaseNoteEl = document.getElementById("phaseNote");

    const minH = 140, maxH = 220;
    const margin = 60;
    const axisY = canvas.height - margin; // membership 0
    const axisX0 = margin;
    const axisX1 = canvas.width - margin;
    const membershipTop = 40;             // membership 1

    let shortBounds = [];
    let tallBounds = [];
    let votes = [];       // store paired short/tall per student for CSV export
    let showResults = false;

    function heightToX(h) {
      return axisX0 + ((h - minH) / (maxH - minH)) * (axisX1 - axisX0);
    }

    function drawAxes() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // X-axis
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(axisX0, axisY);
      ctx.lineTo(axisX1, axisY);
      ctx.stroke();

      // Ticks every 20 cm
      ctx.font = "12px Arial";
      ctx.fillStyle = "#333";
      for (let h = minH; h <= maxH; h += 20) {
        const x = heightToX(h);
        ctx.beginPath();
        ctx.moveTo(x, axisY);
        ctx.lineTo(x, axisY - 8);
        ctx.stroke();
        ctx.fillText(h.toString(), x - 12, axisY + 18);
      }

      // Y labels: 0 and 1
      ctx.fillText("1", axisX0 - 25, membershipTop + 4);
      ctx.fillText("0", axisX0 - 25, axisY + 4);

      // Axis labels
      ctx.font = "14px Arial";
      ctx.fillText("Height (cm)", (axisX0 + axisX1) / 2 - 40, axisY + 40);
      ctx.save();
      ctx.translate(20, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = "center";
      ctx.fillText("Membership (category)", 0, 0);
      ctx.restore();

      // Legend
      ctx.font = "12px Arial";
      ctx.fillStyle = "green";
      ctx.fillText("H_short (short/medium boundary)", axisX0 + 10, 30);
      ctx.fillStyle = "blue";
      ctx.fillText("H_tall (medium/tall boundary)", axisX0 + 10, 48);
    }

    function redraw() {
      drawAxes();
      if (!showResults) return;

      const shortCounts = {};
      shortBounds.forEach(h => {
        const key = h.toString();
        shortCounts[key] = (shortCounts[key] || 0) + 1;
      });

      const tallCounts = {};
      tallBounds.forEach(h => {
        const key = h.toString();
        tallCounts[key] = (tallCounts[key] || 0) + 1;
      });

      // Draw short boundaries: green
      Object.keys(shortCounts).forEach(key => {
        const h = parseFloat(key);
        const count = shortCounts[key];
        const x = heightToX(h);

        ctx.strokeStyle = "green";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, axisY);
        ctx.lineTo(x, membershipTop);
        ctx.stroke();

        const baseRadius = 4;
        const radius = baseRadius + 2 * Math.sqrt(count - 1);
        ctx.fillStyle = "green";
        ctx.beginPath();
        ctx.arc(x, membershipTop, radius, 0, 2 * Math.PI);
        ctx.fill();
      });

      // Draw tall boundaries: blue line + red circle
      Object.keys(tallCounts).forEach(key => {
        const h = parseFloat(key);
        const count = tallCounts[key];
        const x = heightToX(h);

        ctx.strokeStyle = "#1f77b4";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, axisY);
        ctx.lineTo(x, membershipTop);
        ctx.stroke();

        const baseRadius = 4;
        const radius = baseRadius + 2 * Math.sqrt(count - 1);
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(x, membershipTop, radius, 0, 2 * Math.PI);
        ctx.fill();
      });
    }

    // Live listener: update whenever Firestore changes
    onSnapshot(votesRef, (snapshot) => {
      shortBounds = [];
      tallBounds = [];
      votes = [];
      let n = 0;

      snapshot.forEach(d => {
        const data = d.data();
        // new schema: short & tall
        if (typeof data.short === "number" && typeof data.tall === "number") {
          shortBounds.push(data.short);
          tallBounds.push(data.tall);
          votes.push({ short: data.short, tall: data.tall });
          n++;
        } else if (typeof data.height === "number") {
          // legacy schema: single height => treat as tall-only
          tallBounds.push(data.height);
          votes.push({ short: NaN, tall: data.height });
          n++;
        }
      });

      countEl.textContent = `${n} responses collected.`;
      if (!showResults) {
        phaseNoteEl.innerHTML = `<strong>Phase 1:</strong> Collecting responses (graph is hidden).`;
      }
      redraw();
    });

    showBtn.onclick = () => {
      showResults = true;
      phaseNoteEl.innerHTML = `<strong>Phase 2:</strong> Results revealed.`;
      redraw();
    };

    hideBtn.onclick = () => {
      showResults = false;
      phaseNoteEl.innerHTML = `<strong>Phase 1:</strong> Collecting responses (graph is hidden).`;
      redraw();
    };

    clearBtn.onclick = async () => {
      if (!confirm("Delete ALL votes from Firestore?")) return;
      const snap = await getDocs(votesRef);
      const promises = [];
      snap.forEach(d => {
        promises.push(deleteDoc(doc(db, "tall_votes", d.id)));
      });
      await Promise.all(promises);
      shortBounds = [];
      tallBounds = [];
      votes = [];
      showResults = false;
      countEl.textContent = "0 responses collected.";
      phaseNoteEl.innerHTML = `<strong>Phase 1:</strong> Collecting responses (graph is hidden).`;
      redraw();
    };

    // Download current canvas as PNG
    downloadBtn.onclick = () => {
      const link = document.createElement("a");
      link.download = "height_category_boundaries.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    };

    // Download CSV for MATLAB: H_short, H_medium, H_tall
    downloadDataBtn.onclick = () => {
      if (votes.length === 0) {
        alert("No data to download yet.");
        return;
      }

      let csv = "H_short,H_medium,H_tall\n";
      votes.forEach(v => {
        const hs = v.short;
        const ht = v.tall;
        if (!isNaN(hs) && !isNaN(ht)) {
          const hm = (hs + ht) / 2;
          csv += `${hs},${hm},${ht}\n`;
        }
      });

      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "height_boundaries_for_matlab.csv";
      a.click();
      URL.revokeObjectURL(url);
    };

    // Initial draw
    redraw();
  </script>
</body>
</html>
